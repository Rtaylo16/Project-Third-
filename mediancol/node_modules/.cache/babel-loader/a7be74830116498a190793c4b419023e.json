{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react')) : typeof define === 'function' && define.amd ? define(['exports', 'react'], factory) : (global = global || self, factory(global.ReactMinimalPieChart = {}, global.React));\n})(this, function (exports, React) {\n  'use strict';\n\n  var React__default = 'default' in React ? React['default'] : React;\n\n  function degreesToRadians(degrees) {\n    return degrees * Math.PI / 180;\n  }\n\n  function valueBetween(value, min, max) {\n    if (value > max) return max;\n    if (value < min) return min;\n    return value;\n  }\n\n  function extractPercentage(value, percentage) {\n    return percentage / 100 * value;\n  }\n\n  function bisectorAngle(startAngle, lengthAngle) {\n    return startAngle + lengthAngle / 2;\n  }\n\n  function shiftVectorAlongAngle(angle, distance) {\n    var angleRadians = degreesToRadians(angle);\n    return {\n      dx: distance * Math.cos(angleRadians),\n      dy: distance * Math.sin(angleRadians)\n    };\n  }\n\n  function isNumber(value) {\n    return typeof value === 'number';\n  }\n\n  function functionProp(prop, payload) {\n    return typeof prop === 'function' ? prop(payload) : prop;\n  }\n\n  function sumValues(data) {\n    var sum = 0;\n\n    for (var i = 0; i < data.length; i++) {\n      sum += data[i].value;\n    }\n\n    return sum;\n  } // Append \"percentage\", \"degrees\" and \"startAngle\" to each data entry\n\n\n  function extendData(_ref) {\n    var data = _ref.data,\n        totalAngle = _ref.lengthAngle,\n        totalValue = _ref.totalValue,\n        paddingAngle = _ref.paddingAngle,\n        chartStartAngle = _ref.startAngle;\n    var total = totalValue || sumValues(data);\n    var normalizedTotalAngle = valueBetween(totalAngle, -360, 360);\n    var numberOfPaddings = Math.abs(normalizedTotalAngle) === 360 ? data.length : data.length - 1;\n    var singlePaddingDegrees = Math.abs(paddingAngle) * Math.sign(totalAngle);\n    var degreesTakenByPadding = singlePaddingDegrees * numberOfPaddings;\n    var degreesTakenByPaths = normalizedTotalAngle - degreesTakenByPadding;\n    var lastSegmentEnd = 0;\n    var extendedData = []; // @NOTE: Shall we evaluate percentage accordingly to dataEntry.value's sign?\n\n    for (var i = 0; i < data.length; i++) {\n      var dataEntry = data[i];\n      var valueInPercentage = total === 0 ? 0 : dataEntry.value / total * 100;\n      var degrees = extractPercentage(degreesTakenByPaths, valueInPercentage);\n      var startAngle = lastSegmentEnd + chartStartAngle;\n      lastSegmentEnd = lastSegmentEnd + degrees + singlePaddingDegrees;\n      extendedData.push(Object.assign({\n        percentage: valueInPercentage,\n        startAngle: startAngle,\n        degrees: degrees\n      }, dataEntry));\n    }\n\n    return extendedData;\n  }\n\n  function _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n\n    for (i = 0; i < sourceKeys.length; i++) {\n      key = sourceKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      target[key] = source[key];\n    }\n\n    return target;\n  }\n\n  function Label(_ref) {\n    var dataEntry = _ref.dataEntry,\n        dataIndex = _ref.dataIndex,\n        props = _objectWithoutPropertiesLoose(_ref, [\"dataEntry\", \"dataIndex\"]);\n\n    return /*#__PURE__*/React__default.createElement(\"text\", Object.assign({\n      dominantBaseline: \"central\"\n    }, props));\n  }\n\n  Label.displayName = 'ReactMinimalPieChartLabel';\n\n  function round(number) {\n    var divisor = 1e14; // 14 decimals\n\n    return Math.round((number + Number.EPSILON) * divisor) / divisor;\n  }\n\n  function evaluateTextAnchorPosition(_ref) {\n    var labelPosition = _ref.labelPosition,\n        lineWidth = _ref.lineWidth,\n        labelHorizontalShift = _ref.labelHorizontalShift;\n    var dx = round(labelHorizontalShift); // Label in the vertical center\n\n    if (dx === 0) {\n      return 'middle';\n    } // Outward label\n\n\n    if (labelPosition > 100) {\n      return dx > 0 ? 'start' : 'end';\n    } // Inward label\n\n\n    var innerRadius = 100 - lineWidth;\n\n    if (labelPosition < innerRadius) {\n      return dx > 0 ? 'end' : 'start';\n    } // Overlying label\n\n\n    return 'middle';\n  }\n\n  function renderLabelElement(renderLabel, labelProps) {\n    var label = renderLabel(labelProps);\n\n    if (typeof label === 'string' || typeof label === 'number') {\n      return /*#__PURE__*/React__default.createElement(Label, Object.assign({\n        key: \"label-\" + (labelProps.dataEntry.key || labelProps.dataIndex)\n      }, labelProps), label);\n    }\n\n    if (React__default.isValidElement(label)) {\n      return label;\n    }\n\n    return null;\n  }\n\n  function renderLabels(data, props) {\n    return data.map(function (dataEntry, index) {\n      var _functionProp;\n\n      var segmentsShift = (_functionProp = functionProp(props.segmentsShift, index)) != null ? _functionProp : 0;\n      var distanceFromCenter = extractPercentage(props.radius, props.labelPosition) + segmentsShift;\n\n      var _shiftVectorAlongAngl = shiftVectorAlongAngle(bisectorAngle(dataEntry.startAngle, dataEntry.degrees), distanceFromCenter),\n          dx = _shiftVectorAlongAngl.dx,\n          dy = _shiftVectorAlongAngl.dy; // This object is passed as argument to the \"label\" function prop\n\n\n      var labelRenderProps = {\n        x: props.center[0],\n        y: props.center[1],\n        dx: dx,\n        dy: dy,\n        textAnchor: evaluateTextAnchorPosition({\n          labelPosition: props.labelPosition,\n          lineWidth: props.lineWidth,\n          labelHorizontalShift: dx\n        }),\n        dataEntry: dataEntry,\n        dataIndex: index,\n        style: functionProp(props.labelStyle, index)\n      };\n      return props.label && renderLabelElement(props.label, labelRenderProps);\n    });\n  }\n\n  var partialCircle = function partialCircle(cx, cy, r, start, end) {\n    var length = end - start;\n    if (length === 0) return [];\n    var fromX = r * Math.cos(start) + cx;\n    var fromY = r * Math.sin(start) + cy;\n    var toX = r * Math.cos(end) + cx;\n    var toY = r * Math.sin(end) + cy;\n    var large = Math.abs(length) <= Math.PI ? '0' : '1';\n    var sweep = length < 0 ? '0' : '1';\n    return [['M', fromX, fromY], ['A', r, r, 0, large, sweep, toX, toY]];\n  };\n\n  var svgPartialCircle = partialCircle;\n\n  function makePathCommands(cx, cy, startAngle, lengthAngle, radius) {\n    var patchedLengthAngle = valueBetween(lengthAngle, -359.999, 359.999);\n    return svgPartialCircle(cx, cy, // center X and Y\n    radius, degreesToRadians(startAngle), degreesToRadians(startAngle + patchedLengthAngle)).map(function (command) {\n      return command.join(' ');\n    }).join(' ');\n  }\n\n  function Path(_ref) {\n    var cx = _ref.cx,\n        cy = _ref.cy,\n        lengthAngle = _ref.lengthAngle,\n        lineWidth = _ref.lineWidth,\n        radius = _ref.radius,\n        _ref$shift = _ref.shift,\n        shift = _ref$shift === void 0 ? 0 : _ref$shift,\n        reveal = _ref.reveal,\n        rounded = _ref.rounded,\n        startAngle = _ref.startAngle,\n        title = _ref.title,\n        props = _objectWithoutPropertiesLoose(_ref, [\"cx\", \"cy\", \"lengthAngle\", \"lineWidth\", \"radius\", \"shift\", \"reveal\", \"rounded\", \"startAngle\", \"title\"]);\n\n    var pathRadius = radius - lineWidth / 2; //@NOTE This shift might be rendered as a translation in future\n\n    var _shiftVectorAlongAngl = shiftVectorAlongAngle(bisectorAngle(startAngle, lengthAngle), shift),\n        dx = _shiftVectorAlongAngl.dx,\n        dy = _shiftVectorAlongAngl.dy;\n\n    var pathCommands = makePathCommands(cx + dx, cy + dy, startAngle, lengthAngle, pathRadius);\n    var strokeDasharray;\n    var strokeDashoffset; // Animate/hide paths with \"stroke-dasharray\" + \"stroke-dashoffset\"\n    // https://css-tricks.com/svg-line-animation-works/\n\n    if (isNumber(reveal)) {\n      var pathLength = degreesToRadians(pathRadius) * lengthAngle;\n      strokeDasharray = Math.abs(pathLength);\n      strokeDashoffset = strokeDasharray - extractPercentage(strokeDasharray, reveal);\n    }\n\n    return /*#__PURE__*/React__default.createElement(\"path\", Object.assign({\n      d: pathCommands,\n      fill: \"none\",\n      strokeWidth: lineWidth,\n      strokeDasharray: strokeDasharray,\n      strokeDashoffset: strokeDashoffset,\n      strokeLinecap: rounded ? 'round' : undefined\n    }, props), title && /*#__PURE__*/React__default.createElement(\"title\", null, title));\n  }\n\n  Path.displayName = 'ReactMinimalPieChartPath';\n\n  function combineSegmentTransitionsStyle(duration, easing, customStyle) {\n    // Merge chart's animation CSS transition with \"transition\" found to customStyle\n    var transition = \"stroke-dashoffset \" + duration + \"ms \" + easing;\n\n    if (customStyle && customStyle.transition) {\n      transition = transition + \",\" + customStyle.transition;\n    }\n\n    return {\n      transition: transition\n    };\n  }\n\n  function getRevealValue(props) {\n    //@NOTE When animation is on, chart has to be fully revealed when reveal is not set\n    if (props.animate && !isNumber(props.reveal)) {\n      return 100;\n    }\n\n    return props.reveal;\n  }\n\n  function makeEventHandler(eventHandler, payload) {\n    return eventHandler && function (e) {\n      eventHandler(e, payload);\n    };\n  }\n\n  function renderSegments(data, props, revealOverride) {\n    // @NOTE this should go in Path component. Here for performance reasons\n    var reveal = revealOverride != null ? revealOverride : getRevealValue(props);\n    var radius = props.radius,\n        _props$center = props.center,\n        cx = _props$center[0],\n        cy = _props$center[1];\n    var lineWidth = extractPercentage(radius, props.lineWidth);\n    var paths = data.map(function (dataEntry, index) {\n      var segmentsStyle = functionProp(props.segmentsStyle, index);\n      return /*#__PURE__*/React__default.createElement(Path, {\n        cx: cx,\n        cy: cy,\n        key: dataEntry.key || index,\n        lengthAngle: dataEntry.degrees,\n        lineWidth: lineWidth,\n        radius: radius,\n        rounded: props.rounded,\n        reveal: reveal,\n        shift: functionProp(props.segmentsShift, index),\n        startAngle: dataEntry.startAngle,\n        title: dataEntry.title,\n        style: Object.assign({}, segmentsStyle, props.animate && combineSegmentTransitionsStyle(props.animationDuration, props.animationEasing, segmentsStyle)),\n        stroke: dataEntry.color,\n        tabIndex: props.segmentsTabIndex,\n        onBlur: makeEventHandler(props.onBlur, index),\n        onClick: makeEventHandler(props.onClick, index),\n        onFocus: makeEventHandler(props.onFocus, index),\n        onKeyDown: makeEventHandler(props.onKeyDown, index),\n        onMouseOver: makeEventHandler(props.onMouseOver, index),\n        onMouseOut: makeEventHandler(props.onMouseOut, index)\n      });\n    });\n\n    if (props.background) {\n      paths.unshift( /*#__PURE__*/React__default.createElement(Path, {\n        cx: cx,\n        cy: cy,\n        key: \"bg\",\n        lengthAngle: props.lengthAngle,\n        lineWidth: lineWidth,\n        radius: radius,\n        rounded: props.rounded,\n        startAngle: props.startAngle,\n        stroke: props.background\n      }));\n    }\n\n    return paths;\n  }\n\n  var defaultProps = {\n    animationDuration: 500,\n    animationEasing: 'ease-out',\n    center: [50, 50],\n    data: [],\n    labelPosition: 50,\n    lengthAngle: 360,\n    lineWidth: 100,\n    paddingAngle: 0,\n    radius: 50,\n    startAngle: 0,\n    viewBoxSize: [100, 100]\n  };\n\n  function PieChart(props) {\n    var _useState = React.useState(props.animate ? 0 : null),\n        revealOverride = _useState[0],\n        setRevealOverride = _useState[1];\n\n    React.useEffect(function () {\n      if (props.animate) {\n        return startInitialAnimation();\n      }\n\n      function startInitialAnimation() {\n        var animationTimerId;\n        var animationRAFId;\n        animationTimerId = setTimeout(function () {\n          animationTimerId = null;\n          animationRAFId = requestAnimationFrame(function () {\n            animationRAFId = null;\n            setRevealOverride(null); // Start animation\n          });\n        });\n        return function () {\n          animationTimerId && clearTimeout(animationTimerId);\n          animationRAFId && cancelAnimationFrame(animationRAFId);\n        };\n      }\n    }, []);\n    var extendedData = extendData(props);\n    return /*#__PURE__*/React__default.createElement(\"svg\", {\n      viewBox: \"0 0 \" + props.viewBoxSize[0] + \" \" + props.viewBoxSize[1],\n      width: \"100%\",\n      height: \"100%\",\n      className: props.className,\n      style: props.style\n    }, renderSegments(extendedData, props, revealOverride), props.label && renderLabels(extendedData, props), props.children);\n  }\n\n  PieChart.defaultProps = defaultProps;\n  PieChart.displayName = 'ReactMinimalPieChart';\n  exports.PieChart = PieChart;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"sources":["../src/utils.ts","../src/Chart/extendData.ts","../src/Label.tsx","../src/Chart/renderLabels.tsx","../node_modules/svg-partial-circle/index.js","../src/Path.tsx","../src/Chart/renderSegments.tsx","../src/Chart/Chart.tsx"],"names":["degrees","Math","value","percentage","startAngle","lengthAngle","angleRadians","degreesToRadians","dx","distance","dy","prop","sum","i","data","totalAngle","totalValue","paddingAngle","chartStartAngle","total","sumValues","normalizedTotalAngle","valueBetween","numberOfPaddings","singlePaddingDegrees","degreesTakenByPadding","degreesTakenByPaths","lastSegmentEnd","extendedData","dataEntry","valueInPercentage","extractPercentage","dataIndex","props","Label","divisor","number","Number","labelPosition","lineWidth","labelHorizontalShift","round","innerRadius","label","renderLabel","labelProps","React","segmentsShift","functionProp","distanceFromCenter","shiftVectorAlongAngle","bisectorAngle","labelRenderProps","x","y","textAnchor","evaluateTextAnchorPosition","style","renderLabelElement","partialCircle","length","end","fromX","r","fromY","toX","toY","large","sweep","module","patchedLengthAngle","command","cx","cy","radius","shift","reveal","rounded","title","pathRadius","pathCommands","makePathCommands","isNumber","pathLength","strokeDasharray","strokeDashoffset","undefined","Path","transition","customStyle","eventHandler","revealOverride","getRevealValue","paths","segmentsStyle","Object","combineSegmentTransitionsStyle","makeEventHandler","background","defaultProps","animationDuration","animationEasing","center","viewBoxSize","setRevealOverride","useState","useEffect","startInitialAnimation","animationTimerId","setTimeout","animationRAFId","requestAnimationFrame","clearTimeout","cancelAnimationFrame","extendData","renderSegments","renderLabels","PieChart"],"mappings":"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","sourcesContent":["export function degreesToRadians(degrees: number) {\n  return (degrees * Math.PI) / 180;\n}\n\nexport function valueBetween(value: number, min: number, max: number) {\n  if (value > max) return max;\n  if (value < min) return min;\n  return value;\n}\n\nexport function extractPercentage(value: number, percentage: number) {\n  return (percentage / 100) * value;\n}\n\nexport function bisectorAngle(startAngle: number, lengthAngle: number) {\n  return startAngle + lengthAngle / 2;\n}\n\nexport function shiftVectorAlongAngle(angle: number, distance: number) {\n  const angleRadians = degreesToRadians(angle);\n  return {\n    dx: distance * Math.cos(angleRadians),\n    dy: distance * Math.sin(angleRadians),\n  };\n}\n\nexport function isNumber(value: unknown): value is number {\n  return typeof value === 'number';\n}\n\nexport function functionProp<Prop, Payload>(\n  prop: Prop,\n  payload?: Payload\n): Prop extends (...args: any) => any ? ReturnType<Prop> : Prop {\n  return typeof prop === 'function' ? prop(payload) : prop;\n}\n","import { extractPercentage, valueBetween } from '../utils';\nimport type { Data, ExtendedData } from '../commonTypes';\nimport type { PropsWithDefaults as ChartProps } from './Chart';\n\nfunction sumValues(data: Data): number {\n  let sum = 0;\n  for (let i = 0; i < data.length; i++) {\n    sum += data[i].value;\n  }\n  return sum;\n}\n\n// Append \"percentage\", \"degrees\" and \"startAngle\" to each data entry\nexport default function extendData({\n  data,\n  lengthAngle: totalAngle,\n  totalValue,\n  paddingAngle,\n  startAngle: chartStartAngle,\n}: ChartProps): ExtendedData {\n  const total = totalValue || sumValues(data);\n  const normalizedTotalAngle = valueBetween(totalAngle, -360, 360);\n  const numberOfPaddings =\n    Math.abs(normalizedTotalAngle) === 360 ? data.length : data.length - 1;\n  const singlePaddingDegrees = Math.abs(paddingAngle) * Math.sign(totalAngle);\n  const degreesTakenByPadding = singlePaddingDegrees * numberOfPaddings;\n  const degreesTakenByPaths = normalizedTotalAngle - degreesTakenByPadding;\n  let lastSegmentEnd = 0;\n  const extendedData = [];\n\n  // @NOTE: Shall we evaluate percentage accordingly to dataEntry.value's sign?\n  for (let i = 0; i < data.length; i++) {\n    const dataEntry = data[i];\n    const valueInPercentage = total === 0 ? 0 : (dataEntry.value / total) * 100;\n    const degrees = extractPercentage(degreesTakenByPaths, valueInPercentage);\n    const startAngle = lastSegmentEnd + chartStartAngle;\n    lastSegmentEnd = lastSegmentEnd + degrees + singlePaddingDegrees;\n    extendedData.push(\n      Object.assign(\n        {\n          percentage: valueInPercentage,\n          startAngle,\n          degrees,\n        },\n        dataEntry\n      )\n    );\n  }\n  return extendedData;\n}\n","import React from 'react';\nimport type { CSSProperties, SVGProps } from 'react';\nimport type { ExtendedDataEntry } from './commonTypes';\n\nexport type LabelRenderProps = {\n  x: number;\n  y: number;\n  dx: number;\n  dy: number;\n  textAnchor: string;\n  dataEntry: ExtendedDataEntry;\n  dataIndex: number;\n  style?: CSSProperties;\n};\n\ntype Props = SVGProps<SVGTextElement> & LabelRenderProps;\n\nexport default function Label({ dataEntry, dataIndex, ...props }: Props) {\n  return <text dominantBaseline=\"central\" {...props} />;\n}\n\nLabel.displayName = 'ReactMinimalPieChartLabel';\n","import React from 'react';\nimport DefaultLabel from '../Label';\nimport {\n  bisectorAngle,\n  extractPercentage,\n  functionProp,\n  shiftVectorAlongAngle,\n} from '../utils';\nimport type { PropsWithDefaults as ChartProps } from './Chart';\nimport type { LabelRenderProps } from '../Label';\nimport type { ExtendedData, LabelRenderFunction } from '../commonTypes';\n\nfunction round(number: number): number {\n  const divisor = 1e14; // 14 decimals\n  return Math.round((number + Number.EPSILON) * divisor) / divisor;\n}\n\nfunction evaluateTextAnchorPosition({\n  labelPosition,\n  lineWidth,\n  labelHorizontalShift,\n}: {\n  labelPosition: number;\n  lineWidth: number;\n  labelHorizontalShift: number;\n}) {\n  const dx = round(labelHorizontalShift);\n  // Label in the vertical center\n  if (dx === 0) {\n    return 'middle';\n  }\n  // Outward label\n  if (labelPosition > 100) {\n    return dx > 0 ? 'start' : 'end';\n  }\n  // Inward label\n  const innerRadius = 100 - lineWidth;\n  if (labelPosition < innerRadius) {\n    return dx > 0 ? 'end' : 'start';\n  }\n  // Overlying label\n  return 'middle';\n}\n\nfunction renderLabelElement(\n  renderLabel: LabelRenderFunction,\n  labelProps: LabelRenderProps\n): JSX.Element | null {\n  const label = renderLabel(labelProps);\n  if (typeof label === 'string' || typeof label === 'number') {\n    return (\n      <DefaultLabel\n        key={`label-${labelProps.dataEntry.key || labelProps.dataIndex}`}\n        {...labelProps}\n      >\n        {label}\n      </DefaultLabel>\n    );\n  }\n\n  if (React.isValidElement(label)) {\n    return label;\n  }\n  return null;\n}\n\nexport default function renderLabels(data: ExtendedData, props: ChartProps) {\n  return data.map((dataEntry, index) => {\n    const segmentsShift = functionProp(props.segmentsShift, index) ?? 0;\n    const distanceFromCenter =\n      extractPercentage(props.radius, props.labelPosition) + segmentsShift;\n    const { dx, dy } = shiftVectorAlongAngle(\n      bisectorAngle(dataEntry.startAngle, dataEntry.degrees),\n      distanceFromCenter\n    );\n\n    // This object is passed as argument to the \"label\" function prop\n    const labelRenderProps = {\n      x: props.center[0],\n      y: props.center[1],\n      dx,\n      dy,\n      textAnchor: evaluateTextAnchorPosition({\n        labelPosition: props.labelPosition,\n        lineWidth: props.lineWidth,\n        labelHorizontalShift: dx,\n      }),\n      dataEntry,\n      dataIndex: index,\n      style: functionProp(props.labelStyle, index),\n    };\n\n    return props.label && renderLabelElement(props.label, labelRenderProps);\n  });\n}\n","'use strict'\n\n// from http://stackoverflow.com/a/18473154\nconst partialCircle = (cx, cy, r, start, end) => {\n\tconst length = end - start\n\tif (length === 0) return []\n\n\tconst fromX = r * Math.cos(start) + cx\n\tconst fromY = r * Math.sin(start) + cy\n\tconst toX = r * Math.cos(end) + cx\n\tconst toY = r * Math.sin(end) + cy\n\tconst large = Math.abs(length) <= Math.PI ? '0' : '1'\n\tconst sweep = length < 0 ? '0' : '1'\n\n\treturn [\n\t\t['M', fromX, fromY],\n\t\t['A', r, r, 0, large, sweep, toX, toY]\n\t]\n}\n\nmodule.exports = partialCircle\n","import React from 'react';\nimport type { SVGProps } from 'react';\nimport partialCircle from 'svg-partial-circle';\nimport {\n  bisectorAngle,\n  degreesToRadians,\n  extractPercentage,\n  isNumber,\n  shiftVectorAlongAngle,\n  valueBetween,\n} from './utils';\n\nexport function makePathCommands(\n  cx: number,\n  cy: number,\n  startAngle: number,\n  lengthAngle: number,\n  radius: number\n): string {\n  const patchedLengthAngle = valueBetween(lengthAngle, -359.999, 359.999);\n\n  return partialCircle(\n    cx,\n    cy, // center X and Y\n    radius,\n    degreesToRadians(startAngle),\n    degreesToRadians(startAngle + patchedLengthAngle)\n  )\n    .map((command) => command.join(' '))\n    .join(' ');\n}\n\ntype Props = SVGProps<SVGPathElement> & {\n  cx: number;\n  cy: number;\n  lengthAngle: number;\n  lineWidth: number;\n  radius: number;\n  reveal?: number;\n  rounded?: boolean;\n  shift?: number;\n  startAngle: number;\n  title?: string | number;\n};\n\nexport default function Path({\n  cx,\n  cy,\n  lengthAngle,\n  lineWidth,\n  radius,\n  shift = 0,\n  reveal,\n  rounded,\n  startAngle,\n  title,\n  ...props\n}: Props) {\n  const pathRadius = radius - lineWidth / 2;\n  //@NOTE This shift might be rendered as a translation in future\n  const { dx, dy } = shiftVectorAlongAngle(\n    bisectorAngle(startAngle, lengthAngle),\n    shift\n  );\n\n  const pathCommands = makePathCommands(\n    cx + dx,\n    cy + dy,\n    startAngle,\n    lengthAngle,\n    pathRadius\n  );\n  let strokeDasharray;\n  let strokeDashoffset;\n\n  // Animate/hide paths with \"stroke-dasharray\" + \"stroke-dashoffset\"\n  // https://css-tricks.com/svg-line-animation-works/\n  if (isNumber(reveal)) {\n    const pathLength = degreesToRadians(pathRadius) * lengthAngle;\n    strokeDasharray = Math.abs(pathLength);\n    strokeDashoffset =\n      strokeDasharray - extractPercentage(strokeDasharray, reveal);\n  }\n\n  return (\n    <path\n      d={pathCommands}\n      fill=\"none\"\n      strokeWidth={lineWidth}\n      strokeDasharray={strokeDasharray}\n      strokeDashoffset={strokeDashoffset}\n      strokeLinecap={rounded ? 'round' : undefined}\n      {...props}\n    >\n      {title && <title>{title}</title>}\n    </path>\n  );\n}\n\nPath.displayName = 'ReactMinimalPieChartPath';\n","import React from 'react';\nimport type { CSSProperties } from 'react';\nimport Path from '../Path';\nimport { extractPercentage, functionProp, isNumber } from '../utils';\nimport type { ExtendedData } from '../commonTypes';\nimport type { PropsWithDefaults as ChartProps } from './Chart';\n\nfunction combineSegmentTransitionsStyle(\n  duration: number,\n  easing: string,\n  customStyle?: CSSProperties\n): { transition: string } {\n  // Merge chart's animation CSS transition with \"transition\" found to customStyle\n  let transition = `stroke-dashoffset ${duration}ms ${easing}`;\n  if (customStyle && customStyle.transition) {\n    transition = `${transition},${customStyle.transition}`;\n  }\n  return {\n    transition,\n  };\n}\n\nfunction getRevealValue<Reveal>(props: { reveal?: Reveal; animate?: boolean }) {\n  //@NOTE When animation is on, chart has to be fully revealed when reveal is not set\n  if (props.animate && !isNumber(props.reveal)) {\n    return 100;\n  }\n  return props.reveal;\n}\n\nfunction makeEventHandler<Event, EventHandler, Payload>(\n  eventHandler: undefined | (EventHandler & Function),\n  payload: Payload\n) {\n  return (\n    eventHandler &&\n    ((e: Event) => {\n      eventHandler(e, payload);\n    })\n  );\n}\n\nexport default function renderSegments(\n  data: ExtendedData,\n  props: ChartProps,\n  revealOverride?: null | number\n) {\n  // @NOTE this should go in Path component. Here for performance reasons\n  const reveal = revealOverride ?? getRevealValue(props);\n  const {\n    radius,\n    center: [cx, cy],\n  } = props;\n  const lineWidth = extractPercentage(radius, props.lineWidth);\n  const paths = data.map((dataEntry, index) => {\n    const segmentsStyle = functionProp(props.segmentsStyle, index);\n    return (\n      <Path\n        cx={cx}\n        cy={cy}\n        key={dataEntry.key || index}\n        lengthAngle={dataEntry.degrees}\n        lineWidth={lineWidth}\n        radius={radius}\n        rounded={props.rounded}\n        reveal={reveal}\n        shift={functionProp(props.segmentsShift, index)}\n        startAngle={dataEntry.startAngle}\n        title={dataEntry.title}\n        style={Object.assign(\n          {},\n          segmentsStyle,\n          props.animate &&\n            combineSegmentTransitionsStyle(\n              props.animationDuration,\n              props.animationEasing,\n              segmentsStyle\n            )\n        )}\n        stroke={dataEntry.color}\n        tabIndex={props.segmentsTabIndex}\n        onBlur={makeEventHandler(props.onBlur, index)}\n        onClick={makeEventHandler(props.onClick, index)}\n        onFocus={makeEventHandler(props.onFocus, index)}\n        onKeyDown={makeEventHandler(props.onKeyDown, index)}\n        onMouseOver={makeEventHandler(props.onMouseOver, index)}\n        onMouseOut={makeEventHandler(props.onMouseOut, index)}\n      />\n    );\n  });\n\n  if (props.background) {\n    paths.unshift(\n      <Path\n        cx={cx}\n        cy={cy}\n        key=\"bg\"\n        lengthAngle={props.lengthAngle}\n        lineWidth={lineWidth}\n        radius={radius}\n        rounded={props.rounded}\n        startAngle={props.startAngle}\n        stroke={props.background}\n      />\n    );\n  }\n\n  return paths;\n}\n","import React, { useState, useEffect } from 'react';\nimport type {\n  CSSProperties,\n  FocusEvent,\n  KeyboardEvent,\n  MouseEvent,\n  ReactNode,\n} from 'react';\nimport extendData from './extendData';\nimport renderLabels from './renderLabels';\nimport renderSegments from './renderSegments';\nimport type { Data, EventHandler, LabelRenderFunction } from '../commonTypes';\n\ntype Props = {\n  animate?: boolean;\n  animationDuration?: number;\n  animationEasing?: string;\n  background?: string;\n  center?: [number, number];\n  children?: ReactNode;\n  className?: string;\n  data: Data;\n  lengthAngle?: number;\n  lineWidth?: number;\n  label?: LabelRenderFunction;\n  labelPosition?: number;\n  labelStyle?:\n    | CSSProperties\n    | ((dataIndex: number) => CSSProperties | undefined);\n  onBlur?: EventHandler<FocusEvent>;\n  onClick?: EventHandler<MouseEvent>;\n  onFocus?: EventHandler<FocusEvent>;\n  onKeyDown?: EventHandler<KeyboardEvent>;\n  onMouseOut?: EventHandler<MouseEvent>;\n  onMouseOver?: EventHandler<MouseEvent>;\n  paddingAngle?: number;\n  radius?: number;\n  reveal?: number;\n  rounded?: boolean;\n  segmentsShift?: number | ((dataIndex: number) => number | undefined);\n  segmentsStyle?:\n    | CSSProperties\n    | ((dataIndex: number) => CSSProperties | undefined);\n  segmentsTabIndex?: number;\n  startAngle?: number;\n  style?: CSSProperties;\n  totalValue?: number;\n  viewBoxSize?: [number, number];\n};\n\nconst defaultProps = {\n  animationDuration: 500,\n  animationEasing: 'ease-out',\n  center: [50, 50] as [number, number],\n  data: [] as Data,\n  labelPosition: 50,\n  lengthAngle: 360,\n  lineWidth: 100,\n  paddingAngle: 0,\n  radius: 50,\n  startAngle: 0,\n  viewBoxSize: [100, 100] as [number, number],\n};\n\nexport type PropsWithDefaults = Props & typeof defaultProps;\n\nexport function PieChart(props: PropsWithDefaults) {\n  const [revealOverride, setRevealOverride] = useState(\n    props.animate ? 0 : null\n  );\n  useEffect(() => {\n    if (props.animate) {\n      return startInitialAnimation();\n    }\n\n    function startInitialAnimation() {\n      let animationTimerId: number | null;\n      let animationRAFId: number | null;\n      animationTimerId = setTimeout(() => {\n        animationTimerId = null;\n        animationRAFId = requestAnimationFrame(() => {\n          animationRAFId = null;\n          setRevealOverride(null); // Start animation\n        });\n      });\n\n      return () => {\n        animationTimerId && clearTimeout(animationTimerId);\n        animationRAFId && cancelAnimationFrame(animationRAFId);\n      };\n    }\n  }, []);\n\n  const extendedData = extendData(props);\n  return (\n    <svg\n      viewBox={`0 0 ${props.viewBoxSize[0]} ${props.viewBoxSize[1]}`}\n      width=\"100%\"\n      height=\"100%\"\n      className={props.className}\n      style={props.style}\n    >\n      {renderSegments(extendedData, props, revealOverride)}\n      {props.label && renderLabels(extendedData, props)}\n      {props.children}\n    </svg>\n  );\n}\n\nPieChart.defaultProps = defaultProps;\nPieChart.displayName = 'ReactMinimalPieChart';\n"]},"metadata":{},"sourceType":"script"}